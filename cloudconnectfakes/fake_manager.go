// Code generated by counterfeiter. DO NOT EDIT.
package cloudconnectfakes

import (
	"sync"

	"github.com/telia-oss/cloudconnect"
)

type FakeManager struct {
	ApprovePendingAttachmentStub        func(*cloudconnect.Attachment) error
	approvePendingAttachmentMutex       sync.RWMutex
	approvePendingAttachmentArgsForCall []struct {
		arg1 *cloudconnect.Attachment
	}
	approvePendingAttachmentReturns struct {
		result1 error
	}
	approvePendingAttachmentReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteAttachmentStub        func(*cloudconnect.Attachment) error
	deleteAttachmentMutex       sync.RWMutex
	deleteAttachmentArgsForCall []struct {
		arg1 *cloudconnect.Attachment
	}
	deleteAttachmentReturns struct {
		result1 error
	}
	deleteAttachmentReturnsOnCall map[int]struct {
		result1 error
	}
	ListAttachmentRoutesStub        func(*cloudconnect.Attachment) ([]*cloudconnect.Route, error)
	listAttachmentRoutesMutex       sync.RWMutex
	listAttachmentRoutesArgsForCall []struct {
		arg1 *cloudconnect.Attachment
	}
	listAttachmentRoutesReturns struct {
		result1 []*cloudconnect.Route
		result2 error
	}
	listAttachmentRoutesReturnsOnCall map[int]struct {
		result1 []*cloudconnect.Route
		result2 error
	}
	ListAttachmentsStub        func() ([]*cloudconnect.Attachment, error)
	listAttachmentsMutex       sync.RWMutex
	listAttachmentsArgsForCall []struct {
	}
	listAttachmentsReturns struct {
		result1 []*cloudconnect.Attachment
		result2 error
	}
	listAttachmentsReturnsOnCall map[int]struct {
		result1 []*cloudconnect.Attachment
		result2 error
	}
	RejectPendingAttachmentStub        func(*cloudconnect.Attachment) error
	rejectPendingAttachmentMutex       sync.RWMutex
	rejectPendingAttachmentArgsForCall []struct {
		arg1 *cloudconnect.Attachment
	}
	rejectPendingAttachmentReturns struct {
		result1 error
	}
	rejectPendingAttachmentReturnsOnCall map[int]struct {
		result1 error
	}
	SetAttachmentTagsStub        func(*cloudconnect.Attachment, map[string]string) error
	setAttachmentTagsMutex       sync.RWMutex
	setAttachmentTagsArgsForCall []struct {
		arg1 *cloudconnect.Attachment
		arg2 map[string]string
	}
	setAttachmentTagsReturns struct {
		result1 error
	}
	setAttachmentTagsReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeManager) ApprovePendingAttachment(arg1 *cloudconnect.Attachment) error {
	fake.approvePendingAttachmentMutex.Lock()
	ret, specificReturn := fake.approvePendingAttachmentReturnsOnCall[len(fake.approvePendingAttachmentArgsForCall)]
	fake.approvePendingAttachmentArgsForCall = append(fake.approvePendingAttachmentArgsForCall, struct {
		arg1 *cloudconnect.Attachment
	}{arg1})
	fake.recordInvocation("ApprovePendingAttachment", []interface{}{arg1})
	fake.approvePendingAttachmentMutex.Unlock()
	if fake.ApprovePendingAttachmentStub != nil {
		return fake.ApprovePendingAttachmentStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.approvePendingAttachmentReturns
	return fakeReturns.result1
}

func (fake *FakeManager) ApprovePendingAttachmentCallCount() int {
	fake.approvePendingAttachmentMutex.RLock()
	defer fake.approvePendingAttachmentMutex.RUnlock()
	return len(fake.approvePendingAttachmentArgsForCall)
}

func (fake *FakeManager) ApprovePendingAttachmentCalls(stub func(*cloudconnect.Attachment) error) {
	fake.approvePendingAttachmentMutex.Lock()
	defer fake.approvePendingAttachmentMutex.Unlock()
	fake.ApprovePendingAttachmentStub = stub
}

func (fake *FakeManager) ApprovePendingAttachmentArgsForCall(i int) *cloudconnect.Attachment {
	fake.approvePendingAttachmentMutex.RLock()
	defer fake.approvePendingAttachmentMutex.RUnlock()
	argsForCall := fake.approvePendingAttachmentArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) ApprovePendingAttachmentReturns(result1 error) {
	fake.approvePendingAttachmentMutex.Lock()
	defer fake.approvePendingAttachmentMutex.Unlock()
	fake.ApprovePendingAttachmentStub = nil
	fake.approvePendingAttachmentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) ApprovePendingAttachmentReturnsOnCall(i int, result1 error) {
	fake.approvePendingAttachmentMutex.Lock()
	defer fake.approvePendingAttachmentMutex.Unlock()
	fake.ApprovePendingAttachmentStub = nil
	if fake.approvePendingAttachmentReturnsOnCall == nil {
		fake.approvePendingAttachmentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.approvePendingAttachmentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) DeleteAttachment(arg1 *cloudconnect.Attachment) error {
	fake.deleteAttachmentMutex.Lock()
	ret, specificReturn := fake.deleteAttachmentReturnsOnCall[len(fake.deleteAttachmentArgsForCall)]
	fake.deleteAttachmentArgsForCall = append(fake.deleteAttachmentArgsForCall, struct {
		arg1 *cloudconnect.Attachment
	}{arg1})
	fake.recordInvocation("DeleteAttachment", []interface{}{arg1})
	fake.deleteAttachmentMutex.Unlock()
	if fake.DeleteAttachmentStub != nil {
		return fake.DeleteAttachmentStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteAttachmentReturns
	return fakeReturns.result1
}

func (fake *FakeManager) DeleteAttachmentCallCount() int {
	fake.deleteAttachmentMutex.RLock()
	defer fake.deleteAttachmentMutex.RUnlock()
	return len(fake.deleteAttachmentArgsForCall)
}

func (fake *FakeManager) DeleteAttachmentCalls(stub func(*cloudconnect.Attachment) error) {
	fake.deleteAttachmentMutex.Lock()
	defer fake.deleteAttachmentMutex.Unlock()
	fake.DeleteAttachmentStub = stub
}

func (fake *FakeManager) DeleteAttachmentArgsForCall(i int) *cloudconnect.Attachment {
	fake.deleteAttachmentMutex.RLock()
	defer fake.deleteAttachmentMutex.RUnlock()
	argsForCall := fake.deleteAttachmentArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) DeleteAttachmentReturns(result1 error) {
	fake.deleteAttachmentMutex.Lock()
	defer fake.deleteAttachmentMutex.Unlock()
	fake.DeleteAttachmentStub = nil
	fake.deleteAttachmentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) DeleteAttachmentReturnsOnCall(i int, result1 error) {
	fake.deleteAttachmentMutex.Lock()
	defer fake.deleteAttachmentMutex.Unlock()
	fake.DeleteAttachmentStub = nil
	if fake.deleteAttachmentReturnsOnCall == nil {
		fake.deleteAttachmentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteAttachmentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) ListAttachmentRoutes(arg1 *cloudconnect.Attachment) ([]*cloudconnect.Route, error) {
	fake.listAttachmentRoutesMutex.Lock()
	ret, specificReturn := fake.listAttachmentRoutesReturnsOnCall[len(fake.listAttachmentRoutesArgsForCall)]
	fake.listAttachmentRoutesArgsForCall = append(fake.listAttachmentRoutesArgsForCall, struct {
		arg1 *cloudconnect.Attachment
	}{arg1})
	fake.recordInvocation("ListAttachmentRoutes", []interface{}{arg1})
	fake.listAttachmentRoutesMutex.Unlock()
	if fake.ListAttachmentRoutesStub != nil {
		return fake.ListAttachmentRoutesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listAttachmentRoutesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) ListAttachmentRoutesCallCount() int {
	fake.listAttachmentRoutesMutex.RLock()
	defer fake.listAttachmentRoutesMutex.RUnlock()
	return len(fake.listAttachmentRoutesArgsForCall)
}

func (fake *FakeManager) ListAttachmentRoutesCalls(stub func(*cloudconnect.Attachment) ([]*cloudconnect.Route, error)) {
	fake.listAttachmentRoutesMutex.Lock()
	defer fake.listAttachmentRoutesMutex.Unlock()
	fake.ListAttachmentRoutesStub = stub
}

func (fake *FakeManager) ListAttachmentRoutesArgsForCall(i int) *cloudconnect.Attachment {
	fake.listAttachmentRoutesMutex.RLock()
	defer fake.listAttachmentRoutesMutex.RUnlock()
	argsForCall := fake.listAttachmentRoutesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) ListAttachmentRoutesReturns(result1 []*cloudconnect.Route, result2 error) {
	fake.listAttachmentRoutesMutex.Lock()
	defer fake.listAttachmentRoutesMutex.Unlock()
	fake.ListAttachmentRoutesStub = nil
	fake.listAttachmentRoutesReturns = struct {
		result1 []*cloudconnect.Route
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) ListAttachmentRoutesReturnsOnCall(i int, result1 []*cloudconnect.Route, result2 error) {
	fake.listAttachmentRoutesMutex.Lock()
	defer fake.listAttachmentRoutesMutex.Unlock()
	fake.ListAttachmentRoutesStub = nil
	if fake.listAttachmentRoutesReturnsOnCall == nil {
		fake.listAttachmentRoutesReturnsOnCall = make(map[int]struct {
			result1 []*cloudconnect.Route
			result2 error
		})
	}
	fake.listAttachmentRoutesReturnsOnCall[i] = struct {
		result1 []*cloudconnect.Route
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) ListAttachments() ([]*cloudconnect.Attachment, error) {
	fake.listAttachmentsMutex.Lock()
	ret, specificReturn := fake.listAttachmentsReturnsOnCall[len(fake.listAttachmentsArgsForCall)]
	fake.listAttachmentsArgsForCall = append(fake.listAttachmentsArgsForCall, struct {
	}{})
	fake.recordInvocation("ListAttachments", []interface{}{})
	fake.listAttachmentsMutex.Unlock()
	if fake.ListAttachmentsStub != nil {
		return fake.ListAttachmentsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listAttachmentsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) ListAttachmentsCallCount() int {
	fake.listAttachmentsMutex.RLock()
	defer fake.listAttachmentsMutex.RUnlock()
	return len(fake.listAttachmentsArgsForCall)
}

func (fake *FakeManager) ListAttachmentsCalls(stub func() ([]*cloudconnect.Attachment, error)) {
	fake.listAttachmentsMutex.Lock()
	defer fake.listAttachmentsMutex.Unlock()
	fake.ListAttachmentsStub = stub
}

func (fake *FakeManager) ListAttachmentsReturns(result1 []*cloudconnect.Attachment, result2 error) {
	fake.listAttachmentsMutex.Lock()
	defer fake.listAttachmentsMutex.Unlock()
	fake.ListAttachmentsStub = nil
	fake.listAttachmentsReturns = struct {
		result1 []*cloudconnect.Attachment
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) ListAttachmentsReturnsOnCall(i int, result1 []*cloudconnect.Attachment, result2 error) {
	fake.listAttachmentsMutex.Lock()
	defer fake.listAttachmentsMutex.Unlock()
	fake.ListAttachmentsStub = nil
	if fake.listAttachmentsReturnsOnCall == nil {
		fake.listAttachmentsReturnsOnCall = make(map[int]struct {
			result1 []*cloudconnect.Attachment
			result2 error
		})
	}
	fake.listAttachmentsReturnsOnCall[i] = struct {
		result1 []*cloudconnect.Attachment
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) RejectPendingAttachment(arg1 *cloudconnect.Attachment) error {
	fake.rejectPendingAttachmentMutex.Lock()
	ret, specificReturn := fake.rejectPendingAttachmentReturnsOnCall[len(fake.rejectPendingAttachmentArgsForCall)]
	fake.rejectPendingAttachmentArgsForCall = append(fake.rejectPendingAttachmentArgsForCall, struct {
		arg1 *cloudconnect.Attachment
	}{arg1})
	fake.recordInvocation("RejectPendingAttachment", []interface{}{arg1})
	fake.rejectPendingAttachmentMutex.Unlock()
	if fake.RejectPendingAttachmentStub != nil {
		return fake.RejectPendingAttachmentStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.rejectPendingAttachmentReturns
	return fakeReturns.result1
}

func (fake *FakeManager) RejectPendingAttachmentCallCount() int {
	fake.rejectPendingAttachmentMutex.RLock()
	defer fake.rejectPendingAttachmentMutex.RUnlock()
	return len(fake.rejectPendingAttachmentArgsForCall)
}

func (fake *FakeManager) RejectPendingAttachmentCalls(stub func(*cloudconnect.Attachment) error) {
	fake.rejectPendingAttachmentMutex.Lock()
	defer fake.rejectPendingAttachmentMutex.Unlock()
	fake.RejectPendingAttachmentStub = stub
}

func (fake *FakeManager) RejectPendingAttachmentArgsForCall(i int) *cloudconnect.Attachment {
	fake.rejectPendingAttachmentMutex.RLock()
	defer fake.rejectPendingAttachmentMutex.RUnlock()
	argsForCall := fake.rejectPendingAttachmentArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) RejectPendingAttachmentReturns(result1 error) {
	fake.rejectPendingAttachmentMutex.Lock()
	defer fake.rejectPendingAttachmentMutex.Unlock()
	fake.RejectPendingAttachmentStub = nil
	fake.rejectPendingAttachmentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) RejectPendingAttachmentReturnsOnCall(i int, result1 error) {
	fake.rejectPendingAttachmentMutex.Lock()
	defer fake.rejectPendingAttachmentMutex.Unlock()
	fake.RejectPendingAttachmentStub = nil
	if fake.rejectPendingAttachmentReturnsOnCall == nil {
		fake.rejectPendingAttachmentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rejectPendingAttachmentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) SetAttachmentTags(arg1 *cloudconnect.Attachment, arg2 map[string]string) error {
	fake.setAttachmentTagsMutex.Lock()
	ret, specificReturn := fake.setAttachmentTagsReturnsOnCall[len(fake.setAttachmentTagsArgsForCall)]
	fake.setAttachmentTagsArgsForCall = append(fake.setAttachmentTagsArgsForCall, struct {
		arg1 *cloudconnect.Attachment
		arg2 map[string]string
	}{arg1, arg2})
	fake.recordInvocation("SetAttachmentTags", []interface{}{arg1, arg2})
	fake.setAttachmentTagsMutex.Unlock()
	if fake.SetAttachmentTagsStub != nil {
		return fake.SetAttachmentTagsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setAttachmentTagsReturns
	return fakeReturns.result1
}

func (fake *FakeManager) SetAttachmentTagsCallCount() int {
	fake.setAttachmentTagsMutex.RLock()
	defer fake.setAttachmentTagsMutex.RUnlock()
	return len(fake.setAttachmentTagsArgsForCall)
}

func (fake *FakeManager) SetAttachmentTagsCalls(stub func(*cloudconnect.Attachment, map[string]string) error) {
	fake.setAttachmentTagsMutex.Lock()
	defer fake.setAttachmentTagsMutex.Unlock()
	fake.SetAttachmentTagsStub = stub
}

func (fake *FakeManager) SetAttachmentTagsArgsForCall(i int) (*cloudconnect.Attachment, map[string]string) {
	fake.setAttachmentTagsMutex.RLock()
	defer fake.setAttachmentTagsMutex.RUnlock()
	argsForCall := fake.setAttachmentTagsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) SetAttachmentTagsReturns(result1 error) {
	fake.setAttachmentTagsMutex.Lock()
	defer fake.setAttachmentTagsMutex.Unlock()
	fake.SetAttachmentTagsStub = nil
	fake.setAttachmentTagsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) SetAttachmentTagsReturnsOnCall(i int, result1 error) {
	fake.setAttachmentTagsMutex.Lock()
	defer fake.setAttachmentTagsMutex.Unlock()
	fake.SetAttachmentTagsStub = nil
	if fake.setAttachmentTagsReturnsOnCall == nil {
		fake.setAttachmentTagsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setAttachmentTagsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.approvePendingAttachmentMutex.RLock()
	defer fake.approvePendingAttachmentMutex.RUnlock()
	fake.deleteAttachmentMutex.RLock()
	defer fake.deleteAttachmentMutex.RUnlock()
	fake.listAttachmentRoutesMutex.RLock()
	defer fake.listAttachmentRoutesMutex.RUnlock()
	fake.listAttachmentsMutex.RLock()
	defer fake.listAttachmentsMutex.RUnlock()
	fake.rejectPendingAttachmentMutex.RLock()
	defer fake.rejectPendingAttachmentMutex.RUnlock()
	fake.setAttachmentTagsMutex.RLock()
	defer fake.setAttachmentTagsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ cloudconnect.Manager = new(FakeManager)
